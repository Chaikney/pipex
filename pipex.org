#+title:     pipex
#+author:    Chris Haikney
#+email:     chaikney@student.42urduliz.com
* core requirements
src_sh{./pipex file1 cmd1 cmd2 file2}
must behave the same as:
src_sh{< file1 cmd1 | cmd2 >file2}
So first question is what exactly is that behaviour?
And what is its error handling like?
* Bonus requirements
Bonuses for:
- multiple pipes
  Sounds like a design / extendibility thing.
- << and >> "when the first parameter is "here_doc""
  What does << and >> do, then?
  The double means "create file or append to it if it already exists". The concept is often called heredocs, fish dismisses it as a special case of pipes but bash and zsh have them.
  https://www.gnu.org/software/bash/manual/html_node/Redirections.html
**  >>
This is easier to understand; append to file if it exists (I think I have used this)
** <<
This is the "heredoc" case which I understand much less.
#+begin_quote
read input from the current source until a line containing only word (with no trailing blanks) is seen. All of the lines read up to that point are then used as the standard input (or file descriptor n if n is specified) for a command.
#+end_quote
* manpages (or equivalent) to read for this
** [?] pipe
I assume pipe2 (with the flags) is off limits.
#+begin_src c
  #include <unistd.h>
  int	pipe(int pipefd[2]);
#+end_src
Opens a pipe with 2 fds (0 = read end, 1 = write end).
returns 0 on success, -1 on failure.
*** [?] where do we get the two fds from? can have stdin and stdout, but we are also passing things to commands, so how do we get the fd for the inpout to those. Is it the same as the PID?
** dup and dup2
duplicate a file descriptor
*** [?] why would you want to do that?
Maybe the close-on-exec flag? That can be different for the new processes?
#+begin_quote
The two file descriptors do not share file  descriptor  flags  (the  close-on-exec flag).   The  close-on-exec  flag (FD_CLOEXEC; see fcntl(2)) for the duplicate de‚Äê scriptor is off.
#+end_quote
Maybe also to copy the value to another place.
for this project I think the big thing is to put STDOUT of one to STDIN of another.
*** dup2
src_c{int dup2(int oldfd, int newfd);}
Like dup but it allows you to specify the newfd to use. Important if you know what one of those should be. Important if you know what one of those should be, i.e. the fd of file1 becomes/replaces STDIN of cmd1.
Both functions return the new fd on success, -1 if no.
** access
from unistd.h
int access(const char *pathname, int mode);
Checks if the calling process (i.e. our program?) is able to access the file at pathname.
modes:
*** F_OK
exists
*** X_OK
executable
*** R_OK
readable
*** W_OK
writable
** fork
Creates a new process by duplicating the calling process
#+begin_quote
On success, the PID of the child process is returned in the parent, and 0 is returned  in  the child.
On  failure,  -1 is returned in the parent, no child process is created, and errno is set appropriately.
#+end_quote
So if your PID is zero, you  are the child process. Does this awareness help us decide what we should be doing in the code?
*** [?] Why would we want to do that?
We want the process to keep running after the command we launch has finished.
#+begin_quote
Mostly, the child process does some setup, like changing directory, resetting signal handlers or resetting file descriptors, and then calls execve() to overlay itself with different code.
#+end_quote
** execve
The man page for this is LONG
#+begin_src c
  int execve(const char *pathname, char *const argv[], char *const envp[]);
#+end_src
Returns -1 on failure, does not return on success because it basically destroys the calling process:
#+begin_quote
execve() does not return on success, and the text, initialized data, uninitialized data (bss), and stack of the calling process are overwritten according to the contents of the newly loaded program.
#+end_quote
This is what will run cmd1 and cmd2.
And this note relates to dup above.
#+begin_quote
By  default, file descriptors remain open across an execve().  File descriptors that are marked close-on-exec are closed; see the description of FD_CLOEXEC  in fcntl(2).
#+end_quote
** wait & waitpid
  src_c{#include <sys/wait.h>}
  src_c{pid_t waitpid(pid_t pid, int *wstatus, int options);}
So similar to wait that they share man pages (man 2 wait).
Wait for state changes in a child of the calling process:
*** terminated
*** stopped by a signal
*** resumed by a signal
** exit
*** man 2 exit.
There is _Exit() or _exit() which terminate the calling process "immediately". That is *not* the one we're looking for.
*** man 3 exit
#+begin_src c
    #include stdlib.h
    void exit (inte get X_OK
** open files
Fairly simple operations, use open to get the fd for the file. Careful with the options.
*** 1 for reading
src_c{in_file = open(argv[1], O_RDONLY);}

*** 2 for writing
this one especially there are more possiblities. WRITE? APPEND?
src_c{out_file = open(argv[4], O_CREAT);}
** launch a new command
*** fork...
Make a child process to run the first command.
But we need a check to make sure that we do the right thing based on are we the parent or child.
When we fork, briefly there are 2 copies of the program running! One has PID 0, the other has the new PID. The fd that they have open are the same:
#+begin_quote
The child inherits copies of the parent's set of open file descriptors.  Each file descriptor in the child refers to the same open file description (see open(2)) as the  corresponding  file  descriptor  in  the parent.  This means that the two file descriptors share open file status flags, file offset, and signal-driven I/O attributes (see  the  description  of F_SETOWN and F_SETSIG in fcntl(2)).
#+end_quote
*** ...set up the pipes
First program run: child process: file1 is STDIN.
Second program run: parent process (waits for child to finish / return with data): file2 is its STDOUT.
What then happens in between?
We have the 2 fds: mario[0], the start of the pipe and mario[1], the end of the pipe.
mario[0] has to take over the STDOUT of the *child* process (first one).
mario[1] has to take over the STDIN of the *parent* (second) process.
NO! The STDOUT must *become* the fd at the start of the pipe.
What do we do  with the fds created? Where are they with the two processes -- do they start identical and here I am changing them? What then happens when one process closes one of the mario fds? Are they closed in both? Must be, because this is them *sharing* the space and processes, no?
*** ...and exec
The parts of this are:
- make sure we have the command name separate from its args
- find the full path for the command
- send it to execve along with the environment (envp)
** Closing parts of pipes
If not, you end up unable to finish the program, as things are still being held for writing.
https://stackoverflow.com/questions/33884291/pipes-dup2-and-exec
In our forked model, close the end of the pipe that you are not going to use. -- mind you created new copies of these both when you forked, therefore they need to be cleaned up. Leave only the process-fd combination that is needed to achieve the transfer.
https://web.stanford.edu/class/archive/cs/cs110/cs110.1204/static/lectures/min/cs110-lecture06-min.html
Might be worth thinkning of the 2 pipe ends as READ and WRITE. ("you learn to read before you can write" is a mnemonic for this apparently.)
"both processes could read or write to the pipe if they wanted."
* Notes on envp
This is a third argument to main, widely used in unix systems, it gives access to the environment variables. Otherwise you would use getenv or something.
src_c{int	main(int argc, char *argv[], char *envp[])}
https://www.gnu.org/software/libc/manual/html_node/Program-Arguments.html
** Finding PATH in envp
You want a line which *begins* with PATH=
The possibilities are split with : and do *not* have a trailing /
* What have others done?
https://github.com/gabcollet/pipex/tree/master
- find path is its own function.
  Much complicated shuffling around forks -- why?
** What the fork is going on?
a parent process and a child process, a process created by a fork and then wait-ed for, for an unclear purpose.
Apparently fork-then-exec is the way that unix has *always* run a new program.
- fork is a complete copy of the calling process,
- _until_ it execs a new program at which point they differ.
  In the example program, I dont much understand the parent and child ordering, seems to be backwards? Ignore the names. One takes the first program and puts its output into a pipe. The other (the one that was copied?) sits around until one of its child processes changes state.
  When the state has changed, that means that we have output from the child process. So the fork-ed fds are then available to get tied to the input of the second process.
(- Remember that pipe returns 2 fds at either end of the pipe.)
- the fork ed process is wait-ed for -- waitpid returns when there is a change of state in its child process.
- What does dup2 do in these two things? It is working with the fds.
* Anki cards to create from this project
** What is envp and how is it accessed.
** function sigs for all in man pages bullet
** pipe fd array, which end is which
** when you fork what is the childs return
* presubmission checklist
- [ ] remove stdio.h from my files
- [ ] remove spare (ft_)printfs
- [ ] norminette all my files (inc libft)
- [ ] compile from fresh checkout
- [ ] run from fresh checkout
- [ ] run all the tests again on the fresh
- [ ] remove tasks.org from main, put in dev branch
- [ ] Silence compilation subtasks (e.g. libft calls)
