#+title:     pipex
#+author:    Chris Haikney
#+email:     chaikney@student.42urduliz.com
* core requirements
src_sh{./pipex file1 cmd1 cmd2 file2}
must behave the same as:
src_sh{< file1 cmd1 | cmd2 >file2}
So first question is what exactly is that behaviour?
And what is its error handling like?
* Bonus requirements
Bonuses for:
- multiple pipes
  Sounds like a design / extendibility thing.
- << and >> "when the first parameter is "here_doc""
  What does << and >> do, then?
  The double means "create file or append to it if it already exists". The concept is often called heredocs, fish dismisses it as a special case of pipes but bash and zsh have them.
  https://www.gnu.org/software/bash/manual/html_node/Redirections.html
**  >>
This is easier to understand; append to file if it exists (I think I have used this)
** <<
This is the "heredoc" case which I understand much less.
#+begin_quote
read input from the current source until a line containing only word (with no trailing blanks) is seen. All of the lines read up to that point are then used as the standard input (or file descriptor n if n is specified) for a command.
#+end_quote
* manpages (or equivalent) to read for this
** [?] pipe
I assume pipe2 (with the flags) is off limits.
#+begin_src c
  #include <unistd.h>
  int	pipe(int pipefd[2]);
#+end_src
Opens a pipe with 2 fds (0 = read end, 1 = write end).
returns 0 on success, -1 on failure.
*** [?] where do we get the two fds from? can have stdin and stdout, but we are also passing things to commands, so how do we get the fd for the inpout to those. Is it the same as the PID?
** perror
Print system error message -- looks useful for tidier crashes.      src_c{void perror(const char *s);}
** strerror
returns a pointer to a string describing an errorcode. Use with perror, requires string.h
src_c{char *strerror(int errnum);}
** access
from unistd.h
int access(const char *pathname, int mode);
Checks if the calling process (i.e. our program?) is able to access the file at pathname.
modes:
*** F_OK
exists
*** X_OK
executable
*** R_OK
readable
*** W_OK
writable
** dup
duplicate a file descriptor
*** [?] why would you want to do that?
Maybe the close-on-exec flag?
#+begin_quote
The two file descriptors do not share file  descriptor  flags  (the  close-on-exec flag).   The  close-on-exec  flag (FD_CLOEXEC; see fcntl(2)) for the duplicate de‚Äê scriptor is off.
#+end_quote
** dup2
Like dup but it allows you to specify the newfd to use.
Both functions return the new fd on success, -1 if no.
** execve
#+begin_src c
  int execve(const char *pathname, char *const argv[], char *const envp[]);
#+end_src
This is what would run cmd1 and cmd2 I think.
Potentially complicated callsig, if you pass envvars at the end. And this note relates to dup above.
#+begin_quote
By  default, file descriptors remain open across an execve().  File descriptors that are marked close-on-exec are closed; see the description of FD_CLOEXEC  in fcntl(2).
#+end_quote
** exit
*** man 2 exit.
There is _Exit() or _exit() which terminate the calling process "immediately". That is *not* the one we're looking for.
*** man 3 exit
#+begin_src c
    #include stdlib.h
    void exit (int status);
#+end_src
Causes normal process termination and "the least significant byte of status is returned to the parent".
I have used this already and EXIT_SUCCESS and EXIT_FAILURE are standard so I can use them, probably useful here.
** fork
Creates a new process by duplicating the calling process
#+begin_quote
On success, the PID of the child process is returned in the parent, and 0 is returned  in  the child.
On  failure,  -1 is returned in the parent, no child process is created, and errno is set appropriately.
#+end_quote
So if your PID is zero, you  are the child process. Does this awareness help us decide what we should be doing in the code?
*** [?] Why would we want to do that?
** unlink
delete a name and possibly the file it refers to. (man 2 unlink) If its the last link to it, it goes provided there are no processes with it open.
Another one that I need to know what the pieces of the puzzle are,
** wait & waitpid
  src_c{#include <sys/wait.h>}
  src_c{pid_t waitpid(pid_t pid, int *wstatus, int options);}
So similar to wait that they share man pages (man 2 wait).
Wait for state changes in a child of the calling process:
*** terminated
*** stopped by a signal
*** resumed by a signal
* Possible task breakdown
** open link to stdin and stdout
** read parameters and check that the commands exist(?)
Do they have to?
Use access to make sure that we can do things with them (X_OK?)
"is this a file / is this a command"
- cmd1 and 2 must be searched for in the PATH.
** reading from PATH
- available in envp.
- what is that's format? SOme things are :-separated.
- join cmd to a PATH part and see if we get X_OK
** launch a new command
** open file 1 for reading
** open file 2 for writing
* Notes on envp
This is a third argument to main, widely used in unix systems, it gives access to the environment variables. Otherwise you would use getenv or something.
src_c{int	main(int argc, char *argv[], char *envp[])}
https://www.gnu.org/software/libc/manual/html_node/Program-Arguments.html
** Finding PATH in envp
You want a line which *begins* with PATH=
The possibilities are split with : and do *not* have a trailing /
* What have others done?
https://github.com/gabcollet/pipex/tree/master
- find path is its own function.
  Much complicated shuffling around forks -- why?
** What the fork is going on?
a parent process and a child process, a process created by a fork and then wait-ed for, for an unclear purpose.
Apparently fork-then-exec is the way that unix has *always* run a new program.
- fork is a complete copy of the calling process,
- _until_ it execs a new program at which point they differ.
  In the example program, I dont much understand the parent and child ordering, seems to be backwards? Ignore the names. One takes the first program and puts its output into a pipe. The other (the one that was copied?) sits around until one of its child processes changes state.
  When the state has changed, that means that we have output from the child process. So the fork-ed fds are then available to get tied to the input of the second process.
(- Remember that pipe returns 2 fds at either end of the pipe.)
- the fork ed process is wait-ed for -- waitpid returns when there is a change of state in its child process.
- What does dup2 do in these two things? It is working with the fds.
* presubmission checklist
- [ ] remove stdio.h from my files
- [ ] remove spare (ft_)printfs
- [ ] norminette all my files (inc libft)
- [ ] compile from fresh checkout
- [ ] run from fresh checkout
- [ ] run all the tests again on the fresh
- [ ] remove tasks.org from main, put in dev branch
- [ ] Silence compilation subtasks (e.g. libft calls)
