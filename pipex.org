#+title:     pipex
#+author:    Chris Haikney
#+email:     chaikney@student.42urduliz.com
* requirements
src_sh{./pipex file1 cmd1 cmd2 file2}
must behave the same as:
src_sh{< file1 cmd1 | cmd2 >file2}
So first question is what exactly is that behaviour?
And what is its error handling like?
Bonuses for:
- multiple pipes
  Sounds like a design / extendibility thing.
- << and >> "when the first parameter is "here_doc""
  What does << and >> do, then?
* manpages (or equivalent) to read for this
- [ ] pipe
  I assume pipe2 (with the flags) is off limits.
 #+begin_src c
#include <unistd.h>
int	pipe(int pipefd[2]);
 #+end_src
 Opens a pipe with 2 fds (0 = read end, 1 = write end).
 returns 0 on success, -1 on failure.
  - [?] where do we get the two fds from? can have stdin and stdout, but we are also passing things to commands, so how do we get the fd for the inopout to those. Is it the same as the PID?
- [ ] perror
- [ ] strerror
- [X] access
  int access(const char *pathname, int mode);
  Checks if the calling process (i.e. our program?) is able to access the file at pathname.
  modes:
  - F_OK
    exists
  - X_OK
    executable
  - R_OK
    readable
  - W_OK
    writable

- [X] dup
  duplicate a file descriptor
  - [?] why would you want to do that?
    Maybe the close-on-exec flag?
    #+begin_quote
    The two file descriptors do not share file  descriptor  flags  (the  close-on-exec flag).   The  close-on-exec  flag (FD_CLOEXEC; see fcntl(2)) for the duplicate de‚Äê scriptor is off.
#+end_quote
- [X] dup2
  Like dup but it allows you to specify the newfd to use.
  Both functions return the new fd on success, -1 if no.
- [X] execve
  #+begin_src c
int execve(const char *pathname, char *const argv[], char *const envp[]);
#+end_src
  This is what would run cmd1 and cmd2 I think.
  Potentially complicated callsig, if you pass envvars at the end. And this note relates to dup above.
 #+begin_quote
By  default, file descriptors remain open across an execve().  File descriptors that are marked close-on-exec are closed; see the description of FD_CLOEXEC  in fcntl(2).
 #+end_quote
- [X] exit
  - man 2 exit.
  There is _Exit() or _exit() which terminate the calling process "immediately". That is *not* the one we're looking for.
  - man 3 exit
   #+begin_src c
#include stdlib.h
void exit (int status);
   #+end_src
    Causes normal process termination and "the least significant byte of status is returned to the parent".
    I have used this already and EXIT_SUCCESS and EXIT_FAILURE are standard so I can use them, probably useful here.
- [X] fork
  Creates a new process by duplicating the calling process
  - [?] Why would we want to do that?
- [X] unlink
  delete a name and possibly the file it refers to. (man 2 unlink) If its the last link to it, it goes provided there are no processes with it open.
  Another one that I need to know what the pieces of the puzzle are,
- [X] wait & waitpid
	src_c{pid_t waitpid(pid_t pid, int *wstatus, int options);}
  So similar to wait that they share man pages (man 2 wait).
  Wait for state changes in a child of the calling process:
 - terminated
 - stopped by a signal
 - resumed by a signal
* Possible task breakdown
** open link to stdin and stdout
** read parameters and check that the commands exist(?)
Do they have to?
Use access to make sure that we can do things with them (X_OK?)
* presubmission checklist
- [ ] remove stdio.h from my files
- [ ] remove spare (ft_)printfs
- [ ] norminette all my files (inc libft)
- [ ] compile from fresh checkout
- [ ] run from fresh checkout
- [ ] run all the tests again on the fresh
- [ ] remove tasks.org from main, put in dev branch
- [ ] Silence compilation subtasks (e.g. libft calls)
